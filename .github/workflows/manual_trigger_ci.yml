
---
name: Manual Trigger GLCI
on:
  workflow_dispatch:
    inputs:
      pr_number:
        description: "PR number to test"
        required: true
        default: '54'

jobs:
  glci-syntax:
    name: '.gitlab-ci.yml Syntax'
    runs-on: ubuntu-16.04
    outputs:
      exists: ${{ steps.glci-file-exists.outputs.exists }}
      valid: ${{ steps.validate-glci-file.outputs.valid }}
      pr_head: ${{ steps.user-repo-permissions.outputs.permitted }}
    steps:
      - uses: actions/github-script@v3
        id: get-pr-head
        with:
          github-token: ${{secrets.GITHUB_TOKEN}}
          # See:
          #   - https://octokit.github.io/rest.js/
          script: |
            console.log('== start')
            const pr = await github.pulls.get({
              context.repo.owner,
              context.repo.repo,
              github.events.inputs.pr_number,
            })
            console.log(`== Found PR ${github.events.inputs.pr_number}`)
            console.log(pr)
            # - [ ]

###            const has_write_access = perm_lvl => (perm_lvl == "admin" || perm_lvl == "write" )
###            const write_access_desc = perm_bool => (perm_bool ? "PERMISSION OK" : "PERMISSION DENIED" )
###            if( has_write_access(project_permission.data.permission )){
###              core.setOutput( 'permitted', 'true' )
###            } else {
###              core.setOutput( 'permitted', 'false' )
###              console.log(`::error ::payload user '${context.payload.sender.login}' does not have CI trigger permission for '${context.repository}; not triggering external CI'`)
###            }
###            console.log(`== payload user '${context.payload.sender.login}' CI trigger permission for '${context.repo.owner}': ${write_access_desc(has_write_access(project_permission.data.permission))}`)
      - uses: actions/checkout@v2
        with:
          repository: ${{ github.event.pull_request.head.repo.full_name }}
          ref: ${{ github.event.pull_request.head.ref }}
      - name: 'Does GLCI file exist?'
        id: glci-file-exists
        run: |
          if [ -f .gitlab-ci.yml ]; then
            echo '.gitlab-ci.yml exists'
            echo '::set-output name=exists::true'
          else
            echo '::error ::The ".gitlab-ci.yml" file is missing!'
            echo '::set-output name=exists::false'
            false
          fi
      - name: 'Validate GLCI file syntax'
        id: validate-glci-file
        if: steps.glci-file-exists.outputs.exists == 'true'
        env:
          GITLAB_API_URL: ${{ secrets.GITLAB_API_URL }}       # https://gitlab.com/api/v4
          GITLAB_API_PRIVATE_TOKEN: ${{ secrets.GITLAB_API_PRIVATE_TOKEN }}
        run: |
          GITLAB_API_URL="${GITLAB_API_URL:-https://gitlab.com/api/v4}"
          CURL_CMD=(curl --http1.1 --fail --silent --show-error --header 'Content-Type: application/json' --data @-)
          [ -n "$GITLAB_API_PRIVATE_TOKEN" ] && CURL_CMD+=(--header "Authorization: Bearer $GITLAB_API_PRIVATE_TOKEN")
          data="$(jq --null-input --arg yaml "$(<.gitlab-ci.yml)" '.content=$yaml' )"
          response="$(echo "$data" | "${CURL_CMD[@]}" "${GITLAB_API_URL}/ci/lint?include_merged_yaml=true" | jq . )"
          status=$( echo "$response" | jq .status )
          if [[ "$status" == '"valid"' ]]; then
            echo '.gitlab-ci.yml is valid'
            echo '::set-output name=valid::true'
          else
            echo '::set-output name=valid::false'
            echo '::error::The .gitlab-ci.yml" file is invalid!'
            echo "$response" | jq -r '.errors[] | . = "::error ::\(.)"'
            printf  "::debug ::.gitlab-ci.yml CI lint service response: %s\n" "$response"
            false
          fi

  dump_contexts:
    name: 'Examine Context contents'
    if: always()
    runs-on: ubuntu-16.04
    steps:
      - name: Dump contexts
        env:
          GITHUB_CONTEXT: ${{ toJson(github) }}
        run: echo "$GITHUB_CONTEXT"
      - name: Dump needs context
        env:
          ENV_CONTEXT: ${{ toJson(needs) }}
        run: echo "$ENV_CONTEXT"
      - name: Dump env vars
        run: env | sort

